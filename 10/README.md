# Тема 10: ООП (Объектно-Ориентированное Программирование)

## Введение в ООП

Объектно-ориентированное программирование (ООП) - это парадигма программирования, которая основана на концепции объектов, которые представляют собой экземпляры классов. Python поддерживает полноценное ООП и позволяет создавать классы, объекты и работать с наследованием.

## Классы и объекты

### Создание классов

Класс - это шаблон или описание для создания объектов. Он определяет атрибуты (переменные) и методы (функции), которые объекты этого класса будут иметь.

Пример создания класса:

```python
class User:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def hello(self):
        print(f"Привет, меня зовут {self.name} и мне {self.age} лет.")
```

### Создание объектов

Объекты - это экземпляры классов. Они создаются на основе классов и имеют доступ к атрибутам и методам, определенным в классе.

Пример создания объекта:

```python
user_1 = User("Алиса", 30)
user_2 = User("Боб", 25)

user_1.hello()
user_2.hello()
```

## Наследование

Наследование - это механизм, который позволяет создавать новые классы на основе существующих. Новый класс наследует атрибуты и методы родительского класса.

Пример наследования:

```python
class Student(User):
    def __init__(self, name, age, university):
        super().__init__(name, age)
        self.university = university

    def info(self):
        print(f"{self.name} учится в {self.university}.")


student = Student("Карл", 20, "GSTU")
student.hello()
student.info()
```

## Инкапсуляция

Инкапсуляция - это механизм, который позволяет скрыть атрибуты и методы класса от прямого доступа. В Python, атрибуты и методы, начинающиеся с двойного подчеркивания `__`, считаются частными и доступны только внутри класса.

Пример инкапсуляции:

```python
class Bank:
    def __init__(self):
        self.__balance = 1000

    def get_balance(self):
        return self.__balance

    def change_balance(self, sum):
        if sum > 0:
            self.__balance += sum

bank = Bank()
print(bank.__balance())  # Вызовет ошибку, так как __баланс частный
print(bank.get_balance())  # Вернет баланс
```

## Полиморфизм

Полиморфизм - это возможность объектов разных классов обладать одинаковыми методами и атрибутами. Это упрощает взаимодействие с объектами, не зависящими от их конкретного класса.

Пример полиморфизма:

```python
def information(obj):
    obj.hello()

user = User("Джон", 40)
student = Student("Алиса", 22, "GSTU")

information(user)
information(student)
```

## Специальные методы
Специальные методы, также известные как магические методы, в Python представляют собой специфические методы, начинающиеся и заканчивающиеся двойными подчеркиваниями, такие как `__init__`, `__str__`, `__add__` и другие. Они предоставляют способ определения поведения объектов класса в различных контекстах. 

Специальные методы позволяют вам переопределить стандартное поведение операций, таких как инициализация объектов, преобразование объектов в строки, сложение, вызов функций и многое другое.

### Примеры специальных методов

### `__init__`

Метод `__init__` является конструктором класса и вызывается при создании нового объекта. Он используется для инициализации атрибутов объекта.

```python
class Book:
    def __init__(self, name, author):
        self.name = name
        self.author = author

book = Book("Война и мир", "Лев Толстой")
```

### `__str__`

Метод `__str__` позволяет определить строковое представление объекта. Этот метод вызывается при применении функции `str()` к объекту.

```python
class Book:
    def __init__(self, name, author):
        self.name = name
        self.author = author
        
    def __str__(self):
        return f"{self.name} (автор: {self.author})"

book = Book("Война и мир", "Лев Толстой")
print(str(book))  # Вывод: "Война и мир (автор: Лев Толстой)"
```

### `__add__`

Метод `__add__` позволяет определить операцию сложения для объектов класса. Этот метод вызывается при использовании оператора `+`.

```python
class Repeater:
    def __init__(self, text):
        self.text = text
    
    def __call__(self, n):
        return self.text * n
    
repeat = Repeater("Привет, ")
result = repeat(3)  # результат: "Привет, Привет, Привет, "
```

## Декораторы классов
Декораторы классов в Python - это мощный инструмент, позволяющий изменять поведение классов и их методов. Они предоставляют гибкую и эффективную возможность расширения и модификации функциональности классов без изменения их исходного кода. В этом руководстве мы рассмотрим основы работы с декораторами классов.

## Создание декоратора класса

Декоратор класса - это функция, которая принимает класс в качестве аргумента и возвращает новый класс с расширенной функциональностью. Декоратор класса определяется с использованием ключевого слова `@` перед определением класса.

Пример декоратора класса:

```python
def class_decorator(cls):
    class NewClass(cls):
        new_attribute = "New attribute"

        def new_method(self):
            return "New method"

    return NewClass

@class_decorator
class OriginalClass:
    attribute = "Original attribute"

    def method(self):
        return "Original method"

instance = OriginalClass()
print(instance.attribute)  # Вывод: "Original attribute"
print(instance.method())  # Вывод: "Original method"
print(instance.new_attribute)  # Вывод: "New attribute"
print(instance.new_method())  # Вывод: "New method"
```

В приведенном примере декоратор класса `class_decorator` добавляет новый атрибут и метод к исходному классу `OriginalClass`.

#### Применение декораторов классов
Декораторы классов могут использоваться для различных целей, таких как:

1. **Добавление атрибутов и методов:** Декораторы классов могут добавлять новые атрибуты и методы к исходному классу для расширения его функциональности.

2. **Модификация атрибутов и методов:** Декораторы могут изменять существующие атрибуты и методы класса, например, добавлять дополнительную логику или изменять результаты методов.

3. **Кеширование:** Декораторы классов могут использоваться для реализации кеширования результатов методов, что может повысить производительность.

4. **Проверка доступа и авторизация:** Декораторы могут применяться для проверки доступа и авторизации пользователей к определенным методам или атрибутам класса.

### Свойства (Properties)
Свойства - это специальные методы в классах Python, которые позволяют определить, как атрибуты класса могут быть доступны, изменяемы и валидируемы. Они позволяют контролировать доступ к данным объектов и могут быть полезными для обеспечения инкапсуляции и безопасности.

### Создание свойств

Свойства создаются с использованием встроенных декораторов `@property`, `@<атрибут>.setter` и `@<атрибут>.deleter`. Они определяются внутри класса и позволяют переопределить поведение для чтения, записи и удаления атрибутов.

Пример создания свойства:

```python
class Circle:
    def __init__(self, radius):
        self.__radius = radius

    @property
    def radius(self):
        return self.__radius

    @radius.setter
    def radius(self, new_radius):
        if new_radius < 0:
            raise ValueError("Радиус не может быть отрицательным.")
        self.__radius = new_radius

    @radius.deleter
    def radius(self):
        print("Удаление радиуса...")
        del self.__radius

circle = Circle(5)
print(circle.radius)  # Чтение свойства
circle.radius = 7  # Запись свойства
del circle.radius  # Удаление свойства
```

### Преимущества использования свойств
#### Инкапсуляция
Свойства позволяют скрыть атрибуты и обеспечить их частный доступ. Определение методов для чтения и записи свойств позволяет контролировать доступ к данным объектов.

#### Валидация данных
С помощью свойств можно добавить валидацию данных. Например, вы можете проверять, что вводимые значения соответствуют ожиданиям, прежде чем разрешить запись.

#### Управление изменениями
Свойства позволяют выполнить дополнительные действия при чтении или записи атрибута. Например, вы можете логировать изменения или выполнить вычисления на основе значений атрибутов.

## Лучшие практики при работе с ООП

1. **Имена классов**: Используйте имена классов с заглавной буквы и CamelCase стилем (например, `MyClass`).

2. **Комментарии и документация**: Добавляйте комментарии и документацию к вашим классам, методам и атрибутам для улучшения читаемости и понимания кода.

3. **Избегайте глобальных переменных**: Вместо глобальных переменных используйте атрибуты классов.

4. **Применяйте принцип единственной ответственности**: Каждый класс должен иметь одну конкретную задачу.

5. **Тестирование**: Проводите тестирование классов и методов, чтобы удостовериться в их правильной работе.

6. **Имена свойств**: Используйте описательные имена для свойств, чтобы они были легко понятными.

7. **Валидация данных**: Добавляйте проверки и валидацию данных в методы записи свойств, чтобы предотвратить некорректные значения.

8. **Документация**: Добавляйте документацию к свойствам и их методам доступа, чтобы облегчить понимание и использование класса.

9. **Соблюдение соглашения об именовании**: Используйте именование согласно PEP 8 и рекомендациям по именам для методов доступа (например, `get_<attr_name>` и `set_<attr_name>`).


# Литература
1. [Data model](https://docs.python.org/3/reference/datamodel.html)
2. [Гайд по магическим методам в Python](https://tproger.ru/articles/gajd-po-magicheskim-metodam-v-python)
3. [Руководство по магическим методам в Питоне](https://habr.com/ru/articles/186608/)
